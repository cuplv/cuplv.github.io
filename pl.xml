<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE cv [
<!ENTITY emdash "&#8212;">
]>

<cv>
  <news-list>
    <news date="2012.09.25" id="phd-call-2013">
      <news-snippet>
	Call for Ph.D. applicants for Fall 2013.  Application deadline
	is December 15, 2012.
      </news-snippet>
      <news-detail>
	Call for Ph.D. applicants for Fall 2013.  Application deadline
	is December 15, 2012. Check out our latest <a
	href="http://www.cs.colorado.edu/~bec/talks/openhouse11.swf">recruiting
	talk</a> from February 25, 2011.
      </news-detail>
      <news-page header="Ph.D. Positions">
	<p>
	We are looking for strong students to join our diverse and
	dynamic group in programming languages and verification.  Our
	group has active projects in areas such as static and dynamic
	program analysis; verification, debugging, and programmer
	productivity tools; language-based security; type systems;
	language design, compilation, and analysis for dynamic, web
	languages; performance analysis of data center-scale systems;
	analysis of hybrid and embedded systems.  We have a track
	record of publishing in top venues, such as POPL and PLDI.  <a
	href="http://www.colorado.edu/cs/sites/default/files/Department%20of%20Computer%20Science%20Graduate%20Admissions.pdf">CS
	Admissions</a> (deadline December 15, 2012) and <a
	href="http://ecee.colorado.edu/prospective/grad/intro.html">ECEE
	Admissions</a> (deadline February 1, 2013 but earlier for financial aid consideration).
	</p>
      </news-page>
    </news>
    <news date="2012.09.19" id="mvd-2012">
      <news-snippet>
	CUPLV goes to <ref table="event" key="mvd12"/> September 20-21.
      </news-snippet>
    </news>
    <news date="2012.07.30" id="rival-2012">
      <news-snippet>
	<ref table="person" key="rival" /> visits July 30-August 16.
      </news-snippet>
    </news>
    <news date="2012.07.19" id="talk-issta12">
      <news-snippet>
	<ref table="person" key="coughlin"/> is presenting
	at <ref table="event" key="issta12"/> July 19.
      </news-snippet>
      <news-detail>
	<ref table="person" key="coughlin"/> is presenting
	the paper "<ref table="pub" key="enforcements-issta12"/>"
	at <ref table="event" key="issta12"/> on July 19.
      </news-detail>
    </news>
    <news date="2011.07.15" id="goubault-putot-2012">
      <news-snippet>
	<ref table="person" key="goubault"/> and
	<ref table="person" key="putot"/>
	visit July 16-20.
      </news-snippet>
    </news>
    <news date="2012.06.21" id="pldisrc12">
      <news-snippet>
        <ref table="person" key="vitousek"/> awarded third place at the <a href="http://pldi12.cs.purdue.edu/content/student-research-competition">PLDI Student Research Competition (SRC)</a>.
      </news-snippet>
      <news-detail>
        Congratulations to <ref table="person" key="vitousek"/> for being awarded third place at the <a href="http://pldi12.cs.purdue.edu/content/student-research-competition">Programming Language Design and Implementation (PLDI) Student Research Competition (SRC)</a> for his project: Gradual Typing with Efficient Object Casts. 
      </news-detail>
    </news>
    <news date="2012.06.30" id="ivancic-2012">
      <news-snippet>
	<ref table="person" key="ivancic"/> visits July 2.
      </news-snippet>
      <news-detail>
	<ref table="person" key="ivancic"/>
	from NEC Laboratories in Princeton, New Jersey
	is visiting us on July 2, 2012.
	Franjo is giving a talk at 2:00pm in
	ECOT 832 on Monday, July 2, 2012.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="ivancic"/></speaker>
	<affiliation>NEC Laboratories</affiliation>
	<when>07-02-2012 14:00</when>
	<where>ECOT 832</where>
	<title>
	  Program Analysis for C++
	</title>
	<abstract>
	  <p>Program analyzes have been successful in finding serious
	  program defects such as NULL pointer accesses or buffer
	  overflows in programs written in C. However, industry relies
	  heavily on object-oriented languages, such as Java and C++.
	  This talk presents our recent advances in static analysis
	  for C++. It focuses on C++ specific difficulties such as
	  multiple inheritance, conversion from C++ strings to C
	  strings and vice versa, and C++ exception semantics.</p>
	</abstract>
	<bio>
	  <p><ref table="person" key="ivancic"/> is currently a Senior
	  Research Staff Member at NEC Laboratories America in
	  Princeton, NJ. Prior to joining NEC, he received his
	  Ph.D. and MSE degrees in Computer and Information Science
	  from the University of Pennsylvania in Philadelphia,
	  PA. Earlier, he received his diploma (Dipl.-Inform.) degree
	  from the Rheinische Friedrich-Wilhelms-University in Bonn,
	  Germany, for his research performed at the Fraunhofer
	  Institute in St. Augustin, Germany. His areas of research
	  include software verification, model checking, formal
	  modeling and analysis of hybrid systems, and design
	  automation for embedded software. He received the Morris and
	  Dorothy Rubinoff dissertation award from the University of
	  Pennsylvania.</p>
	</bio>
      </talk-announcement>
    </news>
    <news date="2012.06.11" id="chauduri-2012">
      <news-snippet>
	<ref table="person" key="swarat" /> visits June 12.
      </news-snippet>
    </news>
    <news date="2012.05.31" id="thiagarajan-2012">
      <news-snippet>
	<ref table="person" key="thiagu"/> visits June 4-5.
      </news-snippet>
      <news-detail>
	<ref table="person" key="thiagu"/>
	from National University of Singapore
	is visiting us on June 4-5, 2012.
	He is giving a talk at 2:00pm in
	ECOT 831 on Monday, June 4, 2012.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="thiagu"/></speaker>
	<affiliation>National University of Singapore</affiliation>
	<when>06-04-2012 14:00</when>
	<where>ECOT 831</where>
	<title>
	  Probabilistic Approximation and Analysis Bio-pathways Dynamics
	</title>
	<abstract>
	  <p>A system of Ordinary Differential Equations (ODEs) is
	  often used to model the dynamics of a bio-chemical
	  network. Such systems are difficult to analyze. To get
	  around this, we construct a discrete probabilistic
	  approximation of the ODE dynamics as a dynamic Bayesian
	  network.  Consequently, pathway properties can be analyzed
	  using standard Bayesian inference techniques. Apart from
	  testing our method on ODEs models drawn from the biomodels
	  data base, we have used our technique in a combined
	  computational and experimental study of the human complement
	  system under inflammation conditions.  Our results are very
	  encouraging in terms of accuracy and efficiency. Finally, we
	  have extended the scalability of our approach via a GPU
	  implementation.</p>
	</abstract>
	<bio>
	  <p>P.S. Thiagarajan received his B.Tech (Electrical
	  Engineering) from the Indian Institute of Technology (IIT),
	  Madras (1970) and his Ph.D. in Computer Science from Rice
	  university, Houston, Texas, USA (1973).  He is currently a
	  Professor of Computer Science at the National University of
	  Singapore.</p>
	  <p>He has held appointments at the Project MAC (the
	  predecessor of the current Laboratory for Computer Science),
	  Massachusetts Institute of Technology (MIT) (1973-1975),
	  Gesellschaft fuer Mathematik und Datenverarbeitung,
	  St. Augustin, Germany (1975-83), Aarhus University, Denmark
	  (1983-86), Indian Institute of Mathematical Sciences,
	  Chennai, India (1986-89) and the Chennai Mathematical
	  Institute (1989-).</p>
	  <p>He has served as a member of the editorial boards of the
	  journals Theoretical Computer Science and the International
	  Journal on Foundations of Computing . He served two terms
	  (1997 - 2003) as a member of the Governing Council of the
	  European Association for Theoretical Computer Science
	  (EATCS). He is a Fellow of the Indian Academy of Sciences
	  and the Indian National Academy of Sciences.</p>
	  <p>His current research interests are: System-level design
	  and analysis methods for real time embedded systems and
	  computational systems biology.</p>
	</bio>
      </talk-announcement>
    </news>
    <news date="2012.05.21" id="paper-sas12">
      <news-snippet>
	Paper accepted to <ref table="event" key="sas12"/>
	(by <ref table="pub" key="self-reflection-sas12" text="Sanchez et al."/>).
      </news-snippet>
    </news>
    <news date="2012.04.20" id="paper-issta12">
      <news-snippet>
	Paper accepted to <ref table="event" key="issta12"/>
	(by <ref table="pub" key="enforcements-issta12" text="Coughlin et al."/>).
      </news-snippet>
    </news>
    <news date="2012.03.27" id="talk-tacas12">
      <news-snippet>
	<ref table="person" key="cox"/> is presenting
	at <ref table="event" key="tacas12"/> March 27.
      </news-snippet>
      <news-detail>
	<ref table="person" key="cox"/> is presenting
	the paper "<ref table="pub" key="filters-tacas12"/>"
	at <ref table="event" key="tacas12"/> on March 27.
      </news-detail>
    </news>
    <news date="2012.03.23" id="papers-cav12">
      <news-snippet>
	3 papers with CUPLV authors accepted to <ref table="event" key="cav12"/>
	(by <ref table="pub" key="iictl-cav12" text="Hassan et al."/>, <ref table="pub" key="timed-relational-cav12" text="Zutshi et al."/>, and <ref table="pub" key="sl-cav12" text="Berdine et al."/>)
      </news-snippet>
    </news>
    <news date="2012.02.23" id="phdvisit-2012">
      <news-snippet>
	Prospective Ph.D. students visit February 24.
      </news-snippet>
    </news>
    <news date="2012.02.02" id="jeannet-2012">
      <news-snippet>
	<ref table="person" key="bjeannet"/> and <ref table="person"
	key="schramme"/> visit February 6-17.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bjeannet"/> and <ref table="person"
	key="schramme"/> from INRIA Rhône-Alpes in Grenoble, France
	are visiting us for two weeks from February 6, 2012 to
	February 17, 2012.  Bertrand is giving a talk at 3:30pm in
	ECOT 831 on Friday, February 10, 2012, and Peter is presenting
	at 3:30pm in ECOT 831 on Friday, February 17, 2012.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="schramme"/></speaker>
	<affiliation>INRIA Rhône-Alpes</affiliation>
	<when>02-17-2012 15:30</when>
	<where>ECOT 831</where>
	<title>
	  Towards the Verification of Hybrid Data-Flow Languages
	</title>
	<abstract>
	  <p>Hybrid systems are used to model embedded computing
	  systems interacting with their physical environment. There
	  is a conceptual mismatch between high-level hybrid system
	  languages, like Simulink, which are used for simulation, and
	  hybrid automata, the most suitable representation for safety
	  verification. Indeed, in simulation languages the
	  interaction between discrete and continuous execution steps
	  is specified using the concept of zero-crossings, whereas
	  hybrid automata exploit the notion of staying conditions.
	  In this talk we first briefly present Zelus, a synchronous
	  data-flow language extended with ordinary differential
	  equations.  Then we propose a sound translation from a
	  Zelus-like hybrid data-flow formalism to logico-numerical
	  hybrid automata discussing various zero-crossing semantics
	  and the extent to which the original semantics is preserved.
	  At last we sketch how existing continuous reachability
	  analysis methods can be applied to logico-numerical hybrid
	  automata.</p>
	</abstract>
      </talk-announcement>
      <talk-announcement>
	<speaker><ref table="person" key="bjeannet"/></speaker>
	<affiliation>INRIA Rhône-Alpes</affiliation>
	<when>02-10-2012 15:30</when>
	<where>ECOT 831</where>
	<title>
	  The BDDAPRON Logico-Numerical Abstract Domain Library
	</title>
	<abstract>
	  <p>We describe BDDAPRON, a freely available library
	  dedicated to the static analysis of finite-type and
	  numerical variables.</p> 
	  <p>BDDAPRON provides ready-to-use logico-numerical
	  abstractions for combinations of finite-type and numerical
	  variables, as well as powerful symbolic manipulations of
	  expressions.</p> 
	  <p>Algorithmically, BDDAPRON combines BDD techniques (using
	  the CUDD library) with numerical abstract domains provided
	  by the APRON library. We describe the principles behind this
	  combination and the various available options for the
	  computation of abstract transfer functions.</p>
	  <p>At last, we present some applications of the BDDAPRON
	  abstract domain to program verification, including recursive
	  program with pointers.</p>
	</abstract>
      </talk-announcement>
    </news>
    <news date="2012.01.25" id="students-popl12">
      <news-snippet>
	<ref table="person" key="agrawal"/>,
	<ref table="person" key="coughlin"/>,
	<ref table="person" key="cox"/>, and
	<ref table="person" key="silkensen"/> finalists
	at the <ref table="event" key="popl12"/> 
	Student Lightning Talks.
      </news-snippet>
    </news>
    <news date="2011.11.04" id="best-paper-fmcad-2011">
      <news-snippet>
	Best paper at <ref table="event" key="fmcad11"/> goes to
	"<ref table="pub" key="fair-fmcad11"/>".
      </news-snippet>
    </news>
    <news date="2011.11.04" id="faculty-openings-2012">
      <news-snippet>
	Two tenure-track positions open.  Evaluation begins December 6, 2011.
      </news-snippet>
      <news-page header="Faculty Positions (Two Openings)">
	<p>
	  University of Colorado Boulder: Department of Electrical,
	  Computer, and Energy Engineering (ECEE) seeks outstanding
	  candidates for two tenure-track positions in computer
	  systems. The openings are targeted at the level of Assistant
	  Professor, but experienced candidates with outstanding
	  credentials may be considered for Associate or Full
	  Professor.
	</p>
	<p>
	  Candidates interested in rigorous and innovative approaches
	  to the design and analysis of complex computing systems
	  (from embedded and cyberphysical to large-scale distributed
	  systems) should apply. We seek candidates with background in
	  programming languages, concurrency, security, formal
	  methods, verification, or system engineering. Preference
	  will go to researchers whose work spans multiple areas.
	</p>
	<p>
	  The positions will help shape the cooperation with the
	  Department of Computer Science on computing systems.
	</p>
	<p>
	  Candidates must have a Ph.D. in electrical engineering,
	  computer engineering, computer science, or related
	  discipline; they must have the ability to develop an
	  independent research program, and enthusiasm for working
	  with undergraduate and graduate students.
	</p>
	<p>
	  The University of Colorado is an Equal Opportunity Employer
	  committed to building a diverse workforce. We encourage
	  applications from women, minorities candidates, people with
	  disabilities, and veterans.
	</p>
	<p>
	  Applications will be evaluated starting December 6, 2011 and
	  until the positions are filled.
	</p>
	<p>
	  Applications must include a letter of application specifying
	  the desired position and area of specialization, complete
	  curriculum vitae, statements of research and teaching
	  interests, and names and contact information of three
	  references. Applications must be submitted on-line at
	  http://www.jobsatcu.com/ using posting number <a
	  href="http://www.jobsatcu.com/applicants/Central?quickFind=66369">#815103</a>
	  (computer systems). Additional information is available at
	  that site.
	</p>
      </news-page>
    </news>
    <news date="2011.11.04" id="phd-call-2012">
      <news-snippet>
	Call for Ph.D. applicants for Fall 2012.  Application deadline
	is December 15, 2011.
      </news-snippet>
      <news-detail>
	Call for Ph.D. applicants for Fall 2012.  Application deadline
	is December 15, 2011. Check out our latest <a
	href="http://www.cs.colorado.edu/~bec/talks/openhouse11.swf">recruiting
	talk</a> from February 25, 2011.
      </news-detail>
      <news-page header="Ph.D. Positions">
	<p>
	We are looking for strong students to join our diverse and
	dynamic group in programming languages and verification.  Our
	group has active projects in areas such as static and dynamic
	program analysis; verification, debugging, and programmer
	productivity tools; language-based security; type systems;
	language design, compilation, and analysis for dynamic, web
	languages; performance analysis of data center-scale systems;
	analysis of hybrid and embedded systems.  We have a track
	record of publishing in top venues, such as POPL and PLDI.  <a
	href="http://www.cs.colorado.edu/grad/admission/">CS
	Admissions</a> (deadline December 15, 2011) and <a
	href="http://ecee.colorado.edu/prospective/grad/intro.html">ECEE
	Admissions</a> (deadline February 1, 2012 but earlier for financial aid consideration).
	</p>
      </news-page>
    </news>
    <news date="2011.09.09" id="talk-sas11">
      <news-snippet>
	<ref table="person" key="blackshear" /> presenting at
	<ref table="event" key="sas11" /> September 14.
      </news-snippet>
      <news-detail>
	<ref table="person" key="blackshear" /> is presenting
	the paper "<ref table="pub" key="ptaprecision-sas11" />" at
	<ref table="event" key="sas11" /> on September 14.
      </news-detail>
    </news>
    <news date="2011.07.11" id="summer-workshop-2011">
      <news-snippet>
	Summer workshop July 12.
      </news-snippet>
      <news-detail>
	We will have a workshop with visitors
	<ref table="person" key="swarat" /> (Rice University, USA),
	<ref table="person" key="goubault"/> (CEA, France),
	<ref table="person" key="putot"/> (CEA, France), and
	<ref table="person" key="cesar" /> (IMDEA, Spain)
	in ECOT 832 on July 12 10:00am-6:00pm.
      </news-detail>
    </news>
    <news date="2011.07.07" id="goubault-putot-2011">
      <news-snippet>
	<ref table="person" key="goubault"/> and
	<ref table="person" key="putot"/>
	visit July 11-12.
      </news-snippet>
    </news>
    <news date="2011.07.07" id="chauduri-2011">
      <news-snippet>
	<ref table="person" key="swarat" /> visits July 11-15.
      </news-snippet>
    </news>
    <news date="2011.07.01" id="sanchez-2011">
      <news-snippet>
	<ref table="person" key="cesar" /> visits July 5-August 12.
      </news-snippet>
    </news>
    <news date="2011.06.02" id="ivancic-2011">
      <news-snippet>
	<ref table="person" key="ivancic" /> visits June 4.
      </news-snippet>
    </news>
    <news date="2011.04.25" id="reichenbach-2011">
      <news-snippet>
	<ref table="person" key="creichen"/> visits April 25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="creichen"/> from U of Massachusetts,
	Amherst and alumnus of this group is visiting us on Monday,
	April 25, 2011.  He is giving a talk at 10:00am in ECOT 832.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="creichen"/></speaker>
	<affiliation>University of Massachusetts, Amherst</affiliation>
	<when>04-25-2011 10:00</when>
	<where>ECOT 832</where>
	<title>
	  What can the Garbage Collector compute efficiently? A
	  Language for Heap Assertions at Garbage Collection Time
	</title>
	<abstract>
	  <p>Finding bugs is among the most challenging tasks in
	  software development.  For this reason, modern software
	  development methodologies encourage programmers to use
	  assertions throughout their code to express the assumptions
	  they are making.  At runtime, these assertions then detect
	  whenever the assumptions do not match the program; in other
	  words, they detect bugs early.  However, traditional
	  assertion mechanisms in mainstream languages such as C or
	  Java are limited in their expressivity.</p>
	  <p>This talk presents DeAL, a rich heap assertion language
	  for Java that extends over the expressive power of
	  traditional assertions.  DeAL introduces additional
	  primitives to reason over heap layout, allowing programmers
	  to assert global invariants, ownership, and other properties
	  that would be impossible to express in traditional
	  assertions.</p>
	  <p>By design, all DeAL assertions require only a single heap
	  traversal and can execute as part of garbage collection.
	  Consequently, DeAL is not only expressive, but also ensures
	  a very low execution overhead.</p>
	</abstract>
      </talk-announcement>
    </news>
    <news date="2011.02.22" id="stump-2011">
      <news-snippet>
	<ref table="person" key="astump"/> visits February 24-25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="astump"/> from U of Iowa is visiting
	us February 24-25, 2011.  He is giving a talk on Thursday,
	February 24 at 4:30pm in ECOT 832.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="astump"/></speaker>
	<affiliation>University of Iowa</affiliation>
	<when>02-24-2011 16:30</when>
	<where>ECOT 832</where>
	<title>Building Verified Software with Dependent Types</title>
	<abstract>
	  <p>Recent years have seen intensive interest among
	  Programming Language (PL) researchers in connecting PL and
	  Verification.  Static analyses which once were primarily
	  intended for enabling optimizations in compilers are now
	  used also for program verification and bug finding.  Type
	  systems, which had been used to detect (either statically or
	  dynamically) low-level bugs, are now pushed to express
	  stronger and stronger semantic properties of code.  Arguably
	  the most powerful such systems known are so-called dependent
	  type systems, which combine programming and theorem proving,
	  and use rich types to express general logical specifications
	  of programs.</p>
	  <p>In this talk, I will describe ongoing work in my group to
	  design, prove, and implement dependently typed programming
	  languages, and apply them for challenging case studies.  I
	  will summarize the design of the Guru dependently typed
	  programming language, and explain how it overcomes some
	  traditional difficulties for dependently typed languages,
	  concerning general recursion and also the treatment of
	  equality.  For a case study, I will describe recent work of
	  my doctoral student Duckki Oe to implement a statically
	  verified modern SAT solver called versat in Guru. Versat
	  uses the efficient low-level data structures and algorithms
	  of modern solvers like Minisat, but has been statically
	  verified to be sound: if versat reports "unsat", then the
	  input formula is truly contradictory.  Versat can solve
	  benchmarks on the modern scale, including some from the SAT
	  Competition 2009.  I will conclude with a glimpse at a new
	  dependently typed language called Trellys, being designed
	  and implemented in a collaborative project with Stephanie
	  Weirich at U. Pennsylvania and Tim Sheard at Portland
	  State.</p>
	</abstract>
	<bio>
	  Aaron Stump is an associate professor of Computer Science at
	  The University of Iowa, where he co-leads the U. Iowa
	  Computational Logic Center with Cesare Tinelli.  Aaron
	  received his PhD in Computer Science in 2002 from Stanford
	  University.  His research interests are in Computational
	  Logic and Programming Languages, with current focus on
	  dependently typed programming languages and high-performance
	  proof checking.
	</bio>
      </talk-announcement>
    </news>
    <news date="2011.02.06" id="cook-2011">
      <news-snippet>
	<ref table="person" key="bycook"/> visits February 8.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bycook"/> from MSR Cambridge and Queen
	Mary, University of London is visiting us Tuesday, February 8,
	2011.  He is giving a talk at 3:00pm in ECOT 831.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bycook"/></speaker>
	<affiliation>MSR Cambridge and Queen Mary, University of London</affiliation>
	<when>02-08-2011 15:00</when>
	<where>ECOT 831</where>
	<title>Proving stabilisation of biological models</title>
	<abstract>
	  I will describe an efficient procedure for proving
	  stabilisation of biological systems when modeled as
	  qualitative networks or genetic regulatory networks. For
	  scalability, we use modular proof techniques, where
	  state-space exploration is applied only locally to small
	  pieces of the system rather than the entire system as a
	  whole. Our procedure exploits the observation that, in
	  practice, the form of modular proofs can be restricted to a
	  very limited set.  Using our new procedure, we have solved a
	  number of challenging published examples, including: a 3-D
	  model of the mammalian epidermis; a model of metabolic
	  networks operating in type-2 diabetes; a model of fate
	  determination of vulval precursor cells in the C. elegans
	  worm; and a model of pair-rule regulation during
	  segmentation in the Drosophila embryo. Our results show many
	  orders of magnitude speedup in cases where previous
	  stabilization proving techniques were known to succeed, and
	  new results in cases where tools had previously failed.
	</abstract>
	<bio>
	  Dr. Byron Cook is a principal researcher at Microsoft
	  Research Cambridge, as well as Professor of Computer Science
	  at Queen Mary, University of London.  Byron is one of the
	  developers behind the Terminator program termination prover,
	  as well as the SLAM symbolic software model checker which
	  forms the basis of the Windows Static Driver Verifier tool.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.08.01" id="wang-2010">
      <news-snippet>
	<ref table="person" key="chaowang" /> visits August 26-27.
      </news-snippet>
      <news-detail>
	<ref table="person" key="chaowang" /> from NEC Laboratories
	and CU alumnus is visiting us August 26-27.  He is giving a
	talk in the CS Colloquium on Thursday, August 26 3:30pm-4:30pm
	in ECCR 150.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="chaowang"/></speaker>
	<affiliation>NEC Laboratories</affiliation>
	<when>08-26-2010 15:30</when>
	<where>ECCR 150</where>
	<title>Symbolic Predictive Analysis for Concurrent Programs</title>
	<abstract>
	  <p>Multi-core and multi-processor systems are becoming
	  increasingly popular. However, our ability to effectively
	  harness the power of parallelism is predicated upon advances
	  in tools and algorithms for verifying concurrent
	  programs. Concurrent programs are notoriously difficult to
	  verify, and a key reason for this is the behavioral
	  complexity resulting from the large number of interleavings
	  of concurrent threads.</p>
	  <p>In this talk, I will introduce a symbolic predictive
	  analysis for runtime detection of concurrency errors, by
	  monitoring and subsequently analyzing the execution traces
	  of a program. In this analysis, we first derive a symbolic
	  predictive model using the trace information collected at
	  run time as well as the program source code. What this model
	  captures are not just the given traces, but all possible
	  interleavings of events of these traces. Then we use
	  symbolic reasoning to check whether there are concurrency
	  errors in any of these interleavings. This is done by
	  capturing these interleavings and the error conditions using
	  a set of first-order logic formulas, and then deciding the
	  formulas using an off-the-shelf Satisfiability Modulo Theory
	  (SMT) solver.</p>
	</abstract>
	<bio>
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.07.27" id="rival-2010">
      <news-snippet>
	<ref table="person" key="rival" /> visits August 19-25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="rival"/> from INRIA Roquencourt and
	ENS Paris is visiting us August 19-25.  He is giving a talk on
	the Astrée Static Analyzer on Tuesday, August 24 at 11:00am in
	ECOT 831, and he is also giving a more in-depth demonstration
	of Astrée on Wednesday, August 25 4:00pm-5:00pm in ECST 1B21.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="rival"/></speaker>
	<affiliation>INRIA Roquencourt and ENS Paris</affiliation>
	<when>08-24-2010 11:00</when>
	<where>ECOT 831</where>
	<title>The Astrée Analyzer: Proving the absence of runtime
	errors automatically</title>
	<abstract>
	  <p>Runtime errors in embedded softwares may have disastrous
	  consequences, e.g. in transportation or energy production
	  systems.</p>
	  <p>The Astrée analyzer aims at proving the absence of
	  runtime errors in C programs and was designed specifically
	  for synchronous applications as found in fly-by-wire
	  systems. The analysis process is conservative, that is, it
	  may fail to establish the correctness of some safe programs,
	  but it is sound, that is it will report any runtime error.</p>
	  <p>Astrée performs Abstract Interpretation based static
	  analysis, that is abstract execution, using families of
	  predicates formed by abstract domains. Astrée relies on a
	  library of numerical and symbolic abstract domains, which
	  allow to capture salient properties of embedded softwares,
	  so as to establish absence of runtime errors. The analysis
	  process is fully automatic, and involves automatic
	  parameterization of the abstract domains.</p>
	  <p>We will present the underlying concepts of Astrée, and
	  examplify the use of the analyzer on a few selected
	  examples.</p>
	  <p>The Astrée analyzer has allowed to prove the absence of
	  runtime errors in industrial size avionics programs. As of
	  today, Absint Angewandte Informatik provides commercial
	  diffusion and support of Astrée.</p>
	</abstract>
      </talk-announcement>
    </news>
    <news date="2010.07.27" id="ivancic-2010">
      <news-snippet>
	<ref table="person" key="ivancic" /> visits August 2.
      </news-snippet>
    </news>
    <news date="2010.07.26" id="cook-2010">
      <news-snippet>
	<ref table="person" key="bycook"/> visits July 29.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bycook"/> from MSR Cambridge and
	Queen Mary, University of London is visiting us Thursday, July
	29, 2010.  He is giving a talk in the CS Colloquium at 11:00am
	in ECOT 831.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bycook"/></speaker>
	<affiliation>MSR Cambridge and Queen Mary, University of London</affiliation>
	<when>07-29-2010 11:00</when>
	<where>ECOT 831</where>
	<title>New methods for proving temporal properties of infinite-state systems</title>
	<abstract>
	  I will describe some new methods of proving temporal
	  properties of infinite-state programs.  Our approach takes
	  advantage of the fact that linear-temporal properties can
	  often be proved more efficiently using proof techniques
	  usually associated with the branching-time logic CTL.  The
	  caveat is that, in certain instances, nondeterminism in the
	  system's transition relation can cause CTL methods to report
	  counterexamples that are spurious in LTL. To address this
	  problem we describe an algorithm that, as it attempts to
	  apply CTL proof methods, finds and then removes problematic
	  nondeterminism via an analysis on the spurious
	  counterexamples. We must also develop CTL symbolic model
	  checking tools for infinite-state systems.
	</abstract>
	<bio>
	  Dr. Byron Cook is a Principal Researcher at Microsoft
	  Research in Cambridge, UK as well as Professor of Computer
	  Science at Queen Mary, University of London.  He is one of
	  the developers of the Terminator program termination proving
	  tool, as well as the SLAM software model checker.  Before
	  joining Microsoft Research he was a developer in the WIndows
	  OS kernel group.  See research.microsoft.com/~bycook/ for
	  more information.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.07.05" id="suryanarayanan-2010">
      <news-snippet>
	<ref table="person" key="ssuryana" /> visits July 19.
      </news-snippet>
      <news-detail>
	<ref table="person" key="ssuryana"/> from Colorado School of Mines
	is visiting us on Monday, July 19, 2010.  He is giving a talk in
	the CS Colloquium at 3:00pm in DLC 1B70.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="ssuryana"/></speaker>
	<affiliation>Colorado School of Mines</affiliation>
	<when>07-19-2010 15:00</when>
	<where>DLC 1B70</where>
	<title>Realizing the Smart Grid through smart interfaces, microgrids, and active distribution networks</title>
	<abstract>
	  <p>The electricity infrastructure in the US is poised to
	  undergo unprecedented modernization aided by the "Smart Grid
	  Initiative" for achieving high levels of reliability,
	  efficiency, and interconnection of "green" resources. While
	  the advantages of achieving the Smart Grid Initiative appear
	  bountiful, there are concomitant challenges to realizing
	  this transformation. This talk will describe the present
	  state and future trends of the electricity infrastructure,
	  and the need for Smart Grid legislation. The crux of the
	  seminar will focus on how to realize the Smart Grid
	  Initiative's full impact by innovative research and
	  development on:</p>
	  <ul>
	    <li>Smart interfaces between renewable sources and the
	    electricity grid,</li>
	    <li>Energy efficient electric power microgrids, and</li>
	    <li> Transformation from a passive to active electric
	    distribution network.</li>
	  </ul>
	</abstract>
	<bio>
	  Sid Suryanarayanan is from Chennai, India. He received the
	  Ph.D. in electrical engineering from Arizona State
	  University (ASU) in May 2004. Since January 2008 he has held
	  an Assistant Professor position in the Division of
	  Engineering at Colorado School of Mines (CSM) in Golden,
	  CO. From fall 2010, he will begin an Assistant Professorship
	  in the Dept. of Electrical and Computer Engineering (ECE) at
	  Colorado State University. Prior to that he held research
	  appointments in the faculties of Florida State University
	  and ASU. Sid currently performs sponsored research in the
	  areas of electric power microgrids and the impact of the
	  Smart Grid Initiative on electric power systems.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.03.15" id="pierce-2010">
      <news-snippet>
	<ref table="person" key="bcpierce"/> visits April 29.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bcpierce"/> from UPenn
	is visiting Thursday, April 29, 2010.  He is giving
	a talk in the CS Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bcpierce"/></speaker>
	<affiliation>University of Pennsylvania</affiliation>
	<when>04-29-2010 15:30</when>
	<where>ECCR 265</where>
	<title>How to Build Your Own Bidirectional Programming Language</title>
	<abstract>
	  <p>Most programs get used in just one direction, from input
	  to output. But sometimes, having computed an output, we need
	  to be able to update this output and then "calculate
	  backwards" to find a correspondingly updated input. The
	  problem of writing such bidirectional transformations --
	  often called lenses -- arises in applications across a
	  multitude of domains and has been attacked from many
	  perspectives. Potential applications include synchronization
	  of replicated data, system configuration management tools
	  (such as RedHat's Augeas system), bidirectional
	  transformations between software models, and updatable
	  "security views."</p>
	  <p>The Harmony project at the University of Pennsylvania is
	  exploring a linguistic approach to bidirectional
	  programming, designing domain-specific languages in which
	  every expression simultaneously describes both parts of a
	  lens. When read from left to right, an expression denotes an
	  ordinary function that maps inputs to outputs. When read
	  from right to left, it denotes an "update translator" that
	  takes an input together with an updated output and produces
	  a new input that reflects the update. These languages share
	  some common elements with modern functional languages -- in
	  particular, they come with very expressive type systems. In
	  other respects, they are rather novel and surprising.</p>
	  <p>We have designed, implemented, and applied bi-directional
	  languages in three quite different domains: a language for
	  bidirectional transformations on trees (such as XML
	  documents), based on a collection of primitive bidirectional
	  tree transformation operations and
	  "bidirectionality-preserving" combining forms; a language
	  for bidirectional views of relational data, using
	  bidirectionalized versions of the operators of relational
	  algebra as primitives; and, most recently, a language for
	  bidirectional string transformations, with primitives based
	  on standard notations for finite-state transduction and a
	  type system based on regular expressions. The string case is
	  especially interesting, both in its own right and because it
	  exposes a number of foundational issues common to all
	  bidirectional programming languages in a simple and familiar
	  setting. We are also exploring how lenses and their types
	  can be enriched to embody privacy and integrity policies.</p>
	  <p>This talk explores the design of bidirectional languages,
	  starting from the very simplest imaginable variant
	  (bijective languages) and then developing several
	  refinements.</p>
	</abstract>
	<bio>
	  Benjamin Pierce joined the CIS Department at Penn in
	  1998. Previously, he was on the faculty at Indiana
	  University and held research fellowships at Cambridge
	  University, the University of Edinburgh, and
	  INRIA-Roquencourt. He received his PhD in Computer Science
	  at Carnegie Mellon University in 1991. His research centers
	  on programming languages, static type systems, concurrent
	  and distributed programming, and synchronization
	  technologies. His books include the widely used graduate
	  text Types and Programming Languages. He is also the lead
	  designer of the popular Unison file synchronizer.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.03.12" id="burtscher-2010">
      <news-snippet>
	<ref table="person" key="burtscher"/> visits March 18.
      </news-snippet>
      <news-detail>
	<ref table="person" key="burtscher"/> from UT Austin and CU
	alumnus is visiting Thursday, March 18, 2010.  He is giving
	a talk in the CS Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="burtscher"/></speaker>
	<affiliation>The University of Texax at Austin</affiliation>
	<when>03-18-2010 15:30</when>
	<where>ECCR 265</where>
	<title>Towards a Science of Parallel Programming</title>
	<abstract>
	  <p>When parallel programming started in the 70s and 80s, it
	  was mostly art: languages such as functional and logic
	  programming languages were designed and appreciated mainly
	  for their elegance and beauty. More recently, parallel
	  programming has become engineering: conventional languages
	  like FORTRAN and C++ have been extended with constructs such
	  as OpenMP, and we now spend our time benchmarking and
	  tweaking large programs nobody understands to obtain
	  performance improvements of 5-10%. In spite of all this
	  activity, we have few insights into how to write parallel
	  programs to exploit the performance potential of multicore
	  processors.</p>
	  <p>To break this impasse, we need a science of parallel
	  programming. In this talk, I will introduce a concept called
	  "amorphous data-parallelism" that provides a simple, unified
	  picture of parallelism in a host of diverse applications
	  ranging from mesh generation/refinement/partitioning to SAT
	  solvers, maxflow algorithms, stencil computations, and
	  event-driven simulation. Then I will present a natural
	  classification that provides insight into the structure of
	  parallelism and locality in these algorithms and into
	  appropriate language and systems support for exploiting this
	  parallelism.</p>
	</abstract>
	<bio>
	  Martin Burtscher received the combined BS/MS degree in
	  computer science from the Swiss Federal Institute of
	  Technology (ETH) Zurich in 1996 and the PhD degree in
	  computer science from the University of Colorado Boulder in
	  2000. Since then, he has been an assistant professor in the
	  School of Electrical and Computer Engineering at Cornell
	  University and a Research Scientist in the Institute for
	  Computational Engineering and Sciences at the University of
	  Texas at Austin. His current research focuses on automatic
	  parallelization of irregular programs for multicore and GPU
	  architectures as well as on automatic performance assessment
	  and optimization of HPC applications. He is an associate
	  editor of the Journal of Instruction-Level Parallelism and a
	  senior member of the IEEE, its Computer Society, and the
	  ACM.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.02.22" id="chen-2010">
      <news-snippet>
	<ref table="person" key="bradchen"/> visits February 25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bradchen"/> from Google is visiting
	us Thursday, February 25, 2010.  He is giving a talk in the CS
	Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bradchen"/></speaker>
	<affiliation>Google</affiliation>
	<when>02-25-2010 15:30</when>
	<where>ECCR 265</where>
	<title>The Desktop: Frontiers in Systems Research</title>
	<host person="diwan"/>
	<abstract>
	  Desktop software, in the form of web browsers, browser
	  features, and OS distributions, are a growing area of
	  engineering activity at Google. This talk will give an
	  overview of this work, looking in detail at Native Client as
	  an example project in the space. Native Client is an
	  open-source research technology for running x86 native code
	  in web applications, with the goal of maintaining the
	  browser neutrality, OS portability, and safety that people
	  expect from web apps. It supports performance-oriented
	  features generally absent from web application programming
	  environments, such as thread support, instruction set
	  extensions such as SSE, and use of compiler intrinsics and
	  hand-coded assembler. We combine these properties in an open
	  architecture designed to leverage existing web standards,
	  and to encourage community review and third-party
	  tools. Overall, Google's desktop efforts seek to enable new
	  Web applications, improve end-user experience, and enable a
	  more flexible balance between client and server
	  computing. Google has open sourced many of our desktop
	  efforts, in part to encourage collaboration and independent
	  innovation.
	</abstract>
	<bio>
	  J. Bradley Chen manages the Native Client project at Google,
	  where he has also worked on cluster performance analysis
	  projects. Prior to joining Google, he was Director of the
	  Performance Tools Lab in Intel's Software Products
	  Division. Chen served on the faculty of Harvard University
	  from 1994-1998, conducting research in operating systems,
	  computer architecture and distributed system, and teaching a
	  variety of related graduate and undergraduate courses. He
	  has published widely on the subjects of systems performance
	  and computer architecture. Dr. Chen has bachelors and
	  masters degrees from Stanford University and a PhD from
	  Carnegie Mellon University.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.01.13" id="strout-2010">
      <news-snippet>
	<ref table="person" key="mstrout"/> visits January 28.
      </news-snippet>
      <news-detail>
	<ref table="person" key="mstrout"/> from Colorado State is
	visiting us Thursday, January 28, 2010.  She is giving a talk
	in the CS Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="mstrout"/></speaker>
	<affiliation>Colorado State University</affiliation>
	<when>01-28-2010 15:30</when>
	<where>ECCR 265</where>
	<title>Introducing the Sparse Polyhedral Framework</title>
	<abstract>
	  <p>Loops often dominate the execution time of
	  applications. Various transformation frameworks have been
	  developed to enable the automatic compile-time
	  transformation of loops. Many of the existing models fit
	  within the polyhedral framework and although they are quite
	  powerful, they are restricted to compile-time
	  transformations and loop bounds and memory accesses that are
	  affine or can be approximated as affine.</p>
	  <p>In this talk, I will present the Sparse Polyhedral
	  Framework (SPF). The SPF builds on the polyhedral
	  programming model, but is also capable of expressing and
	  supporting the code generation for run-time reordering
	  transformations implemented with inspector/executor
	  strategies. I will then discuss the idea of abstractions for
	  exposing transformation frameworks in performance programmer
	  models.</p>
	</abstract>
	<bio>
	  Michelle Mills Strout is an assistant professor of computer
	  science at Colorado State University. She obtained her PhD
	  in Computer Science from the University of California, San
	  Diego in June 2003. In 2008, Michelle received a CAREER
	  Award from the National Science Foundation for her research
	  in parallelization techniques for irregular applications,
	  such as molecular dynamics simulations. Her main research
	  area is high performance computing and her research
	  interests include compilers and run-time systems, scientific
	  computing, and software engineering.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.01.06" id="bodik-2010">
      <news-snippet>
	<ref table="person" key="bodik"/> visits January 11.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bodik"/> from UC Berkeley is visiting
	us Tuesday, January 11, 2011.  He is giving a talk at 3:00pm
	in DLC 1B70.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bodik"/></speaker>
	<affiliation>University of California Berkeley</affiliation>
	<when>01-11-2010 15:00</when>
	<where>DLC 1B70</where>
	<title>Algorithmic Program Synthesis with Partial Programs</title>
	<abstract>
	  <p>Why hasn't Moore's Law revolutionize programming?  In
	  model checking, cycles fuel bug discovery, improving code
	  quality, but programmers still write programs with their
	  bare hands.  In fact, their work has not changed much since
	  the CRT terminal, except that they think in better
	  languages.</p>
	  <p>Program synthesis might be a way to reduce
	  the programmer's cognitive load.  Synthesizers have derived
	  programs that were highly efficient, and sometimes even
	  surprising.  Of course, they had to be first "programmed"
	  with the human insights about the domain at hand.</p>
	  <p>Which brings us to a key problem in program synthesis ---
	  how to communicate human expertise to the synthesizer.  In
	  deductive synthesis, this expertise is captured in a domain
	  theory.  Often elusive even to formally trained experts, a
	  domain theory is probably not a shortcut to programmer
	  productivity.</p> <p>This talk will describe a growing
	  family of synthesizers based on partial programs.  Their
	  premise is that programs can be decomposed into insight and
	  mechanics: if the programmer encodes her insight as a
	  partial program, the mechanics can then be synthesized given
	  a specification.  Partial programs lend themselves to
	  algorithmic synthesis: rather than deducing a program with a
	  theorem prover, algorithmic synthesis finds the program in a
	  space of candidate implementations described by the partial
	  program.</p>
	  <p>Among five synthesizers, I will describe an algorithm for
	  finding a candidate by constraint solving, rather than via
	  generate-and-test, and a system for programming with angelic
	  non-determinism which computes the insight into a
	  programming problem.</p>
	</abstract>
	<bio>
	  Ras Bodik is an Associate Professor of Computer Science at
	  UC Berkeley.  He is interested in programming systems, from
	  static and dynamic analysis to programmer tools.  He leads a
	  project of program synthesis for high-performance programs
	  based on the idea of program sketches.  He also leads a
	  project on parallel web browsers for mobile devices, which
	  develops parallel parsing and page layout algorithms, as
	  well as a constraints-based scripting language.
	</bio>
      </talk-announcement>
    </news>
    <news date="2009.06.05" id="birkedal-2009">
      <news-snippet>
	<ref table="person" key="birkedal" /> visits July 3.
      </news-snippet>
    </news>
    <news date="2009.03.04" id="pfenning-2009">
      <news-snippet>
	<ref table="person" key="fp" /> visits March 6.
      </news-snippet>
    </news>
  </news-list>

  <projects>
  </projects>

  <publications>
    <pub id="self-reflection-sas12">
      <title>Invariant Generation for Parametrized Systems using Self-Reflection</title>
      <authors>
        <author person="asanchez" />
        <author person="srirams" />
        <author person="cesar" />
        <author person="bec" />
      </authors>
      <urls>
        <url name="pdf">papers/sas12-reflective.pdf</url>
      </urls>
      <howpub>
	<proceedings event="sas12" />
      </howpub>
      <abstract>
        We examine the problem of inferring invariants for
        parametrized systems. Parametrized systems are concurrent
        systems consisting of an a priori unbounded number of process
        instances running the same program. Such systems are commonly
        encountered in many situations including device drivers,
        distributed systems, and robotic swarms. In this paper we
        describe a technique that enables leveraging off-the-shelf
        invariant generators designed for sequential programs to infer
        invariants of parametrized systems. The central challenge in
        invariant inference for parametrized systems is that näıvely
        exploding the transition system with all interleavings is not
        just impractical but impossible. In our approach, the key
        enabler is the notion of a reﬂective abstraction that we prove
        has an important correspondence with inductive
        invariants. This correspondence naturally gives rise to an
        iterative invariant generation procedure that alternates
        between computing candidate invariants and creating reﬂective
        abstractions.
      </abstract>
    </pub>
    <pub id="enforcements-issta12">
      <title>Measuring Enforcement Windows with Symbolic Trace Interpretation: What Well-Behaved Programs Say</title>
      <authors>
	<author person="coughlin" />
	<author person="bec" />
	<author person="diwan" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">papers/issta12-enforcements.pdf</url>
      </urls>
      <howpub>
	<proceedings event="issta12" />
      </howpub>
      <note>
	<tr>
	  <extendedtr />
	  <number>CU-CS-1093-12</number>
	  <url>papers/CU-CS-1093-12-enforcements.pdf</url>
	</tr>
      </note>
      <abstract>
	<p>A static analysis design is <em>sufficient</em> if it can
	prove the property of interest with an acceptable number of
	false alarms.  Ultimately, the only way to confirm that an
	analysis design is sufficient is to implement it and run it on
	real-world programs.  If the evaluation shows that the design
	is insufficient, the designer must return to the drawing board
	and repeat the process&emdash;wasting expensive implementation
	effort over and over again.  In this paper, we make the
	observation that there is a minimal range of code needed to
	prove a property of interest under an ideal static analysis;
	we call such a range of code a <em>validation scope</em>.
	Armed with this observation, we create a dynamic measurement
	framework that quantifies validation scopes and thus enables
	designers to rule out insufficient designs at lower cost.  A
	novel attribute of our framework is the ability to model
	aspects of static reasoning using dynamic execution
	measurements.  To evaluate the flexibility of our framework,
	we instantiate it on an example property&emdash;null
	dereference errors&emdash;and measure validation scopes on
	real-world programs. We use a broad range of metrics that
	capture the difficulty of analyzing programs along varying
	dimensions.  We also examine how validation scopes evolve as
	developers fix null dereference errors and as code matures.
	We find that bug fixes shorten validation scopes, that longer
	validation scopes are more likely to be buggy, and that
	overall validation scopes are remarkably stable as programs
	evolve.</p>
      </abstract>
    </pub>
    <pub id="sl-cav12">
      <title>Diagnosing Abstraction Failure in Separation Logic-based Analyses</title>
      <authors>
        <author person="berdine" />
        <author person="cox" />
        <author person="ishtiaq" />
        <author person="wintersteiger" />
      </authors>
      <urls>
        <url name="pdf">papers/cav12-diag-abs-fail.pdf</url>
      </urls>
      <howpub>
        <proceedings event="cav12" />
      </howpub>
      <abstract>
        <p>Abstraction refinement is an effective verification
        technique for automatically proving safety properties of
        software. Application of this technique in shape analyses has proved
        impractical as core components of existing refinement techniques such
        as backward analysis, general conjunction, and identification of
        unreachable but doomed states are computationally infeasible in such
        domains.</p>
        <p>We propose a new method to diagnose proof failures to
        be used in a refinement scheme for Separation Logic–based shape
        analyses. To check feasibility of abstract error traces, we perform
        Bounded Model Checking over the traces using a novel encoding into
        SMT. A subsequent diagnosis finds discontinuities on infeasible
        traces, and identifies doomed states admitted by the abstraction. To
        construct doomed states, we give a model-finding algorithm for
        “symbolic heap” Separation Logic formulas, employing the execution
        machinery of the feasibility checker to search for concrete
        counter-examples. The diagnosis has been implemented in SLAyer, and we
        present a simple scheme for refining the abstraction of hierarchical
        data structures, and illustrate its effectiveness on benchmarks from
        the SLAyer test suite.</p>
      </abstract>
    </pub>
    <pub id="timed-relational-cav12">
      <title>Timed Relational Abstractions of Sampled-Data Control Systems</title>
      <authors>
        <author person="adityaz" />
        <author person="srirams" />
        <author person="atiwari" />
      </authors>
      <urls>
        <url name="pdf">papers/cav12-timed-relational.pdf</url>
      </urls>
      <howpub>
        <proceedings event="cav12" />
      </howpub>
      <abstract>
        <p>
          In this paper, we define timed relational abstractions for
          verifying sampled data control systems. Sampled data control
          systems consist of a plant, modeled as a hybrid system and a
          synchronous controller, modeled as a discrete transition
          system. The controller computes control inputs and/or sends
          control events to the plant based on the periodically
          sampled state of the plant. The correctness of the system
          depends on the controller design as well as an appropriate
          choice of the controller sampling period.
        </p>
        <p>
          Our approach constructs a timed relational abstraction of
          the hybrid plant by replacing the continuous plant dynamics
          by relations. These relations map a state of the plant to
          states reachable within the sampling time period. We present
          techniques for building timed relational abstractions, while
          taking care of discrete transitions that can be taken by the
          plant between samples. The resulting abstractions are better
          suited for the verification of sampled data control
          systems. The abstractions focus on the states that can be
          observed by the controller at the sample times, while
          abstracting away behaviors between sample times
          conservatively. The resulting abstractions are discrete,
          infinite-state transition systems. Thus conventional
          verification tools can be used to verify safety properties
          of these abstractions. We use k-induction to prove safety
          properties and bounded model checking (BMC) to find
          potential falsifications. We present our idea, its
          implementation and results on many benchmark examples.
        </p>
      </abstract>
    </pub>
    <pub id="iictl-cav12">
      <title>Incremental Inductive CTL Model Checking</title>
      <authors>
        <author person="hassanz" />
        <author person="arbrad" />
        <author person="fabio" />
      </authors>
      <urls>
        <url name="pdf">papers/cav12-iictl.pdf</url>
      </urls>
      <howpub>
        <proceedings event="cav12" />
      </howpub>
      <abstract>
        <p>A SAT-based incremental, inductive algorithm for model
        checking CTL properties is proposed. As in classic CTL model
        checking, the parse graph of the property shapes the
        analysis. However, in the proposed algorithm, called IICTL,
        the analysis is directed by task states that are pushed down
        the parse tree. To each node is associated over- and
        under-approximations to the set of states satisfying that
        node’s property; these approximations are refined until a
        proof that the property does or does not hold is
        obtained. Each CTL operator corresponds naturally to an
        incremental sub-query: given a task state, an EX node executes
        a SAT query; an EU node applies IC3; and an EG node applies
        FAIR. In each case, the query result provides more general
        information than necessary to satisfy the task. When a query
        is satisfiable, the returned trace is generalized using
        forall-exists reasoning, during which IC3 is applied to obtain
        new reachability information that enables greater
        generalization. When a query is unsatisfiable, the proof
        provides the generalization. In this way, property-directed
        abstraction is achieved.
        </p>
      </abstract>
    </pub>
    <pub id="filters-tacas12">
      <title>A Bit Too Precise? Bounded Verification of Quantized Digital Filters</title>
      <authors>
	<author person="cox" />
	<author person="srirams" />
	<author person="bec" />
      </authors>
      <urls>
	<url name="pdf">papers/tacas12-filter_verification.pdf</url>
      </urls>
      <howpub>
	<proceedings event="tacas12" />
      </howpub>
      <abstract>
	<p>Digital filters are simple yet ubiquitous components of a wide
	variety of digital processing and control systems. Errors in
	the filters can be catastrophic.  Traditionally digital
	filters have been verified using methods from control theory
	and extensive testing.  We study two alternative verification
	techniques: bit-precise analysis and real-valued error
	approximations.  In this paper, we empirically evaluate
	several variants of these two fundamental approaches for
	verifying fixed-point implementations of digital filters. We
	design our comparison to reveal the best possible approach
	towards verifying real-world designs of infinite impulse
	response (IIR) digital filters. Our study reveals broader
	insights into cases where bit-reasoning is absolutely
	necessary and suggests efficient approaches using modern
	satisfiability-modulo-theories (SMT) solvers.</p>
      </abstract>
    </pub>
    <pub id="fair-fmcad11">
      <title>An Incremental Approach to Model Checking Progress Properties</title>
      <authors>
	<author person="arbrad" />
	<author person="fabio" />
	<author person="hassanz" />
	<author person="yanzhang" />
      </authors>
      <urls>
	<url name="pdf">http://theory.stanford.edu/~arbrad/papers/fair.pdf</url>
      </urls>
      <howpub>
	<proceedings event="fmcad11" />
      </howpub>
      <abstract>
	<p>An incremental algorithm for model checking progress
	properties is proposed. It follows from the following insight:
	any SCC-closed region of a system’s state graph can be
	represented by a sequence of inductive assertions. Each
	iteration of the algorithm selects a set of states, called a
	skeleton, that together satisfy all fairness conditions; it
	then applies safety model checkers to attempt to connect the
	states into a reachable fair cycle. If this attempt fails, the
	resulting learned lemma takes one of two forms: an inductive
	reachability assertion that shows that at least one state of
	the skeleton is unreachable, or an inductive wall that deﬁnes
	two SCC-closed regions of the state graph. Subsequent
	skeletons must be chosen entirely from one side of the
	wall. Because a lemma often applies more generally than to the
	one skeleton from which it was derived, property-directed
	abstraction is achieved. The algorithm is highly
	parallelizable.</p>
      </abstract>
    </pub>
    <pub id="ptaprecision-sas11">
      <title>The Flow-Insensitive Precision of Andersen's Analysis in Practice</title>
      <authors>
	<author person="blackshear" />
	<author person="bec" />
	<author person="srirams" />
	<author person="msridhar" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/sas11-ptaprecision.pdf</url>
      </urls>
      <howpub>
	<proceedings event="sas11" />
      </howpub>
      <note>
	<tr>
	  <extendedtr />
	  <number>CU-CS-1083-11</number>
	  <url>http://www.cs.colorado.edu/~bec/papers/CU-CS-1083-11-ptaprecision.pdf</url>
	</tr>
      </note>
      <abstract>
	<p>We present techniques for determining the precision gap
	between Andersen's points-to analysis and precise
	flow-insensitive points-to analysis in practice.  While
	previous work has shown that such a gap may exist, no
	efficient algorithm for precise flow-insensitive analysis is
	known, making measurement of the gap on real-world programs
	difficult.  We give an algorithm for precise flow-insensitive
	analysis of programs with finite memory, based on a novel
	technique for refining any points-to analysis with a search
	for flow-insensitive witnesses.  We give a compact symbolic
	encoding of the technique that enables computing the search
	using a tuned SAT solver.  We also present extensions of the
	algorithm that enable computing lower and upper bounds on the
	precision gap in the presence of dynamic memory allocation. In
	our experimental evaluation over a suite of small- to
	medium-sized C programs, we never observed a precision gap
	between Andersen's analysis and the precise analysis. In other
	words, Andersen's analysis computed a precise flow-insensitive
	result for all of our benchmarks.  Hence, we conclude that
	while better algorithms for the precise flow-insensitive
	analysis are still of theoretical interest, their practical
	impact for C programs is likely to be negligible.</p>
      </abstract>
    </pub>
    <pub id="relationalization-cav11">
      <title>Relational Abstractions for Continuous and Hybrid Systems</title>
      <authors>
	<author person="srirams" />
	<author person="atiwari"/>
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~srirams/papers/cav11-relational.pdf</url>
      </urls>
      <howpub> <proceedings event="cav11" /> </howpub>
      <abstract> 
  <p> In this paper, we define relational abstractions of hybrid systems.
  A relational abstraction is obtained by replacing the continuous
  dynamics in each mode by a binary transition relation that relates a
  state of the system to any state that can potentially be reached at
  some future time instant using the continuous dynamics.  We
  construct relational abstractions by reusing template-based
  invariant generation techniques for continuous systems described by
  Ordinary Differential Equations (ODE).  As a result, we abstract a
  given hybrid system as a purely discrete, infinite-state system.  We
  apply k-induction to this abstraction to prove safety properties,
  and use bounded model-checking to find potential falsifications.  We
  present the basic underpinnings of our approach and demonstrate its
  use on many benchmark systems to derive simple and usable
  abstractions. </p>
      </abstract>
    </pub>
    <pub id="linearization-hscc11">
        <title> Automatic Abstraction of Non-Linear Systems Using Change of Variables Transformations </title> 
    <authors>
    <author person="srirams"/>
    </authors>
    <urls> <url name="pdf"> http://www.cs.colorado.edu/~srirams/papers/hscc11.pdf</url>
    </urls>
    <howpub> 
    <proceedings event="hscc11"/>
    </howpub>
    <abstract>
 <p>      We present abstraction techniques that transform a given non-linear
  dynamical system into a linear system, such that, invariant
  properties of the resulting linear abstraction can be used to infer
  invariants for the original system. The abstraction techniques rely
  on a change of bases transformation that associates each state
  variable of the abstract system with a function involving the state
  variables of the original system. We present conditions under which
  a given change of basis transformation for a non-linear system can
  define an abstraction. </p>
  
<p>  Furthermore, we present a technique to discover, given a non-linear
  system, if a change of bases transformation involving degree-bounded
  polynomials yielding a linear system abstraction exists. If so, our
  technique yields the resulting abstract linear system, as well. This
  approach is further extended to search for a change of bases
  transformation that abstracts a given non-linear system into a
  system of linear differential inclusions.  Our techniques enable the
  use of analysis techniques for linear systems to infer invariants
  for non-linear systems. We present preliminary evidence of the
  practical feasibility of our ideas using a prototype implementation. </p>
    </abstract>
    </pub>
    <pub id="staliro-tool-paper">
      <title>S-Taliro: A Tool for Temporal Logic Falsification for Hybrid Systems</title>
      <authors>
	<author person="yeshwanta"/>
	<author person="liuche"/>
	<author person="fainekosg"/>
	<author person="srirams"/>
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~srirams/papers/sTaliro-tacas11.pdf</url>
      </urls>
      <howpub> 
	<proceedings event="tacas11"/>
      </howpub>
      <abstract>
<p>S-TaLiRo is a Matlab (TM) toolbox that searches for trajectories of
minimal robustness in Simulink/Stateflow diagrams. It can analyze
arbitrary Simulink models or user defined functions that model the
system. At the heart of the tool, we use randomized testing based on
stochastic optimization techniques including Monte-Carlo methods and
Ant-Colony Optimization. Among the advantages of the toolbox is the
seamless integration inside the Matlab environment, which is widely
used in the industry for model-based development of control
software. We present the architecture of S-TaLiRo and its working on
an application example.</p>
    </abstract>
    </pub>

    <pub id="template-esop11">
    <title> Generalizing the Template Polyhedral Domain </title>
    <authors>
    <author person="colonm"/>
    <author person="srirams"/>
    </authors>
    <urls>
      <url name="pdf">http://www.cs.colorado.edu/~srirams/papers/gtp-esop10.pdf</url>
    </urls>
    <howpub> 
    <proceedings event="esop11"/>
    </howpub>
    <abstract>
  <p>Template polyhedra generalize weakly relational domains by
  specifying arbitrary fixed linear expressions on the left-hand sides
  of inequalities and undetermined constants on the right. The domain
  operations required for analysis over template polyhedra can be
  computed in polynomial time using linear programming.  In this
  paper, we introduce the generalized template polyhedral domain that
  extends template polyhedra using fixed left-hand side expressions
  with bilinear forms involving program variables and unknown
  parameters to the right. We prove that the domain operations over
  generalized templates can be defined as the ``best possible
  abstractions'' of the corresponding polyhedral domain
  operations. The resulting analysis can straddle the entire space of
  linear relation analysis starting from the template domain to the
  full polyhedral domain.</p>


<p>  We show that analysis in the generalized template domain can be
  performed by dualizing the join, post-condition and widening
  operations.  We also investigate the special case of template
  polyhedra wherein each bilinear form has at most two parameters. For
  this domain, we use the special properties of two dimensional
  polyhedra and techniques from fractional linear programming to
  derive domain operations that can be implemented in polynomial time
  over the number of variables in the program and the size of the
  polyhedra. We present applications of generalized template polyhedra
  to strengthen previously obtained invariants by converting them into
  templates.  We describe an experimental evaluation of an
  implementation over several benchmark systems.</p>
    </abstract>
    </pub>
    <pub id="blame-popl11">
      <title>Blame for All</title>
      <authors>
	<author person="amal" />
	<author person="robby" />
	<author person="siek" />
	<author person="wadler" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/blame-forall-2011.pdf</url>
      </urls>
      <howpub>
	<proceedings event="popl11" />
      </howpub>
      <abstract>
	<p>Several programming languages are beginning to integrate
	static and dynamic typing, including Racket (formerly PLT
	Scheme), Perl 6, and C# 4.0 and the research languages Sage
	(Gronski, Knowles, Tomb, Freund, and Flanagan, 2006) and Thorn
	(Wrigstad, Eugster, Field, Nystrom, and Vitek, 2009). However,
	an important open question remains, which is how to add
	parametric polymorphism to languages that combine static and
	dynamic typing. We present a system that permits a value of
	dynamic type to be cast to a polymorphic type and vice versa,
	with relational parametricity enforced by a kind of dynamic
	sealing along the lines proposed by Matthews and Ahmed (2008)
	and Neis, Dreyer, and Rossberg (2009). Our system includes a
	notion of blame, which allows us to show that when casting
	between a more-precise type and a less-precise type, any cast
	failures are due to the less-precisely-typed portion of the
	program. We also show that a cast from a subtype to its
	supertype cannot fail.</p>
      </abstract>
    </pub>
    <pub id="stack-popl11">
      <title>Calling Context Abstraction with Shapes</title>
      <authors>
	<author person="rival" />
	<author person="bec" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/popl11-stack.pdf</url>
	<url name="ps">http://www.cs.colorado.edu/~bec/papers/popl11-stack.ps</url>
      </urls>
      <howpub>
	<proceedings event="popl11" />
      </howpub>
      <abstract>
	<p>Interprocedural program analysis is often performed by
	computing procedure summaries.  While possible, computing
	adequate summaries is difficult, particularly in the presence
	of recursive procedures.  In this paper, we propose a
	complementary framework for interprocedural analysis based on
	a direct abstraction of the calling context.  Specifically,
	our approach exploits the inductive structure of a calling
	context by treating it directly as a stack of activation
	records.  We then build an abstraction based on separation
	logic with inductive definitions.  A key element of this
	abstract domain is the use of parameters to refine the meaning
	of such call stack summaries and thus express relations across
	activation records and with the heap.  In essence, we define
	an abstract interpretation-based analysis framework for
	recursive programs that permits a fluid per call site
	abstraction of the call stack&emdash;much like how shape analyzers
	enable a fluid per program point abstraction of the heap.</p>
      </abstract>
    </pub>
    <pub id="accessnets-vmcai11">
      <title>Access Nets: Modeling Access to Physical Spaces</title>
      <authors>
	<author person="frohardt" />
	<author person="bec" />
	<author person="srirams" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/accessnets-vmcai11.pdf</url>
	<url name="ps">http://www.cs.colorado.edu/~bec/papers/accessnets-vmcai11.ps</url>
      </urls>
      <howpub>
	<proceedings event="vmcai11" />
      </howpub>
      <note>
	<tr>
	  <extendedtr />
	  <number>CU-CS-1076-10</number>
	  <url>http://www.cs.colorado.edu/~bec/papers/CU-CS-1076-10.pdf</url>
	</tr>
      </note>
      <abstract>
	<p>Electronic, software-managed mechanisms using, for example,
	radio-frequency identification (RFID) cards, enable great
	flexibility in specifying access control policies to physical
	spaces.  For example, access rights may vary based on time of
	day or could differ in normal versus emergency situations.
	With such fine-grained control, understanding and reasoning
	about what a policy permits becomes surprisingly difficult
	requiring knowledge of permission levels, spatial layout, and
	time.  In this paper, we present a formal modeling framework,
	called <fmt kind="tool">Access Nets</fmt>, suitable for describing a
	combination of access permissions, physical spaces, and
	temporal constraints.  Furthermore, we provide evidence that
	model checking techniques are effective in reasoning about
	physical access control policies.  We describe our results
	from a tool that uses reachability analysis to validate
	security policies.</p>
      </abstract>
    </pub>
    <pub id="mix-pldi10">
      <title>Mixing Type Checking and Symbolic Execution</title>
      <authors>
	<author person="khooyp" />
	<author person="bec" />
	<author person="jfoster" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/pldi10-mix.pdf</url>
	<url name="ps">http://www.cs.colorado.edu/~bec/papers/pldi10-mix.ps</url>
      </urls>
      <howpub>
	<proceedings event="pldi10" />
      </howpub>
      <note>
	<tr>
	  <extendedtr />
	  <number>CS-TR-4954</number>
	  <url>http://hdl.handle.net/1903/10115</url>
	</tr>
      </note>
      <abstract>
	<p>Static analysis designers must carefully balance precision
	and efficiency.  In our experience, many static analysis tools
	are built around an elegant, core algorithm, but that
	algorithm is then extensively tweaked to add just enough
	precision for the coding idioms seen in practice, without
	sacrificing too much efficiency.  There are several downsides
	to adding precision in this way: the tool's implementation
	becomes much more complicated; it can be hard for an end-user
	to interpret the tool's results; and as software systems vary
	tremendously in their coding styles, it may require
	significant algorithmic engineering to enhance a tool to
	perform well in a particular software domain.</p>
	<p>In this paper, we present Mix, a novel system that mixes
	type checking and symbolic execution.  The key aspect of our
	approach is that these analyses are applied independently on
	disjoint parts of the program, in an off-the-shelf manner.  At
	the boundaries between nested type checked and symbolically
	executed code regions, we use special mix rules to communicate
	information between the off-the-shelf systems.  The resulting
	mixture is a provably sound analysis that is more precise than
	type checking alone and more efficient than exclusive symbolic
	execution.  In addition, we also describe a prototype
	implementation, <fmt kind="tool">Mixy</fmt>, for C.  Mixy
	checks for potential null dereferences by mixing a
	null/non-null type qualifier inference system with a symbolic
	executor.</p>
      </abstract>
    </pub>
    <pub id="profilers-pldi10">
      <title>Evaluating the Accuracy of Java Profilers</title>
      <authors>
	<author person="toddm" />
	<author person="diwan" />
	<author person="hauswirth" />
	<author person="sweeney" />
      </authors>
      <urls>
	<url name="pdf">papers/mytkowicz-pldi10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="pldi10" />
      </howpub>
      <abstract>
	<p>
	  Performance analysts profile their programs to find methods
	  that are worth optimizing: the "hot" methods. This paper
	  shows that four commonly-used Java profilers (xprof, hprof,
	  jprofile, and yourkit) often disagree on the identity of the
	  hot methods. If two profilers disagree, at least one must be
	  incorrect. Thus, there is a good chance that a profiler will
	  mislead a performance analyst into wasting time optimizing a
	  cold method with little or no performance improvement.
	</p>
	<p>
	  This paper uses causality analysis to evaluate profilers and
	  to gain insight into the source of their incorrectness. It
	  shows that these profilers all violate a fundamental
	  requirement for sampling-based profilers: to be correct, a
	  sampling-based profiler must collect samples randomly.
	</p>
	<p>
	  We show that a proof-of-concept profiler, which collects
	  samples randomly, does not suffer from the above
	  problems. Specifically, we show, using a number of case
	  studies, that our profiler correctly identifies methods that
	  are important to optimize; in some cases other profilers
	  report that these methods are cold and thus not worth
	  optimizing.
	</p>
      </abstract>
    </pub>
    <pub id="threesomes-popl10">
      <title>Threesomes, With and Without Blame</title>
      <authors>
	<author person="siek" />
	<author person="wadler" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/popl10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="popl10" />
      </howpub>
      <abstract>
	<p>The blame calculus of Wadler and Findler gives a high-level
	semantics to casts in higher-order languages. The coercion
	calculus of Henglein, on the other hand, provides an
	instruction set for casts whose normal forms ensure space
	efficiency. In this paper we address two questions: 1) can
	space efficiency be obtained in a high-level semantics? and 2)
	can we precisely characterize the relationship between the
	high and low-level semantics of casts? Towards answering both
	of these questions, we design a cast calculus that summarizes
	a sequence of casts as a threesome cast that contains a source
	type, a target type, and a third middle type that is the
	greatest lower bound of all the types in the sequence. We show
	that the threesome calculus is equivalent to the blame
	calculus and to one of the coercion-based, blame-tracking
	calculi of Siek, Garcia, and Taha. We also show that the
	threesome calculus is space efficient and obtain a tighter
	bound than that of Herman, Tomb, and Flanagan.</p>
      </abstract>
    </pub>
    <pub id="incremental-gpce10">
      <title>Incremental Type-Checking for Type-Reflective Metaprograms</title>
      <authors>
	<author person="miao" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/gpce10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="gpce10" />
      </howpub>
      <abstract>
	<p></p>
      </abstract>
    </pub>
    <pub id="invalidation-cgo10">
      <title>An Efficient Software Transactional Memory Using Commit-Time Invalidation</title>
      <authors>
	<author person="gottschlich" />
	<author person="vachharajani" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/cgo10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="cgo10" />
      </howpub>
      <abstract>
	<p>To improve the performance of transactional memory (TM),
	researchers have found many eager and lazy optimizations for
	conflict detection, the process of determining if transactions
	can commit. Despite these optimizations, nearly all TMs
	perform one aspect of lazy conflict detection in the same
	manner to preserve serializability. That is, they perform
	commit-time validation, where a transaction is checked for
	conflicts with previously committed transactions during its
	commit phase. While commit-time validation is efficient for
	workloads that exhibit limited contention, it can limit
	transaction throughput for contending workloads.

        This paper presents an efficient implementation of commit-time
        invalidation, a strategy where transactions resolve their
        conflicts with in-flight (uncommitted) transactions before
        they commit. Commit-time invalidation supplies the contention
        manager (CM) with data that is unavailable through commit-time
        validation, allowing the CM to make decisions that increase
        transaction throughput. Commit-time invalidation also requires
        notably fewer operations than commit-time validation for
        memory-intensive transactions, uses zero commit-time
        operations for dynamically detected read-only transactions,
        and guarantees full opacity for any transaction in O(N) time,
        an improvement over incremental validation's O(N2) time. Our
        experimental results show that for contending workloads, our
        efficient commit-time invalidating software TM (STM) is up to
        3 x faster than TL2, a state-of-the-art validating STM.</p>
      </abstract>
    </pub>
    <pub id="ssg-esop10">
      <title>Separating Shape Graphs</title>
      <authors>
	<author person="laviron" />
	<author person="bec" />
	<author person="rival" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/esop10-sepshapegraph.pdf</url>
      </urls>
      <howpub>
	  <proceedings event="esop10" />
      </howpub>
      <abstract>
	<p>Detailed memory models that expose individual fields are
	necessary to precisely analyze code that makes use of
	low-level aspects such as, pointers to fields and untagged
	unions.  Yet, higher-level representations that collect fields
	into records are often used because they are typically more
	convenient and efficient in modeling the program heap.  In
	this paper, we present a shape graph representation of memory
	that exposes individual fields while largely retaining the
	convenience of an object-level model.  This representation has
	a close connection to particular kinds of formulas in
	separation logic.  Then, with this representation, we show how
	to extend the <fmt kind="tool">Xisa</fmt> shape analyzer for
	low-level aspects, including pointers to fields, C-style
	nested structures and unions, malloc and free, and array
	values, with minimal changes to the core algorithms (e.g.,
	materialization and summarization).</p>
      </abstract>
    </pub>
    <pub id="gradprog-pldifit09">
      <title>Gradual Programming: Bridging the Semantic Gap (Position Paper)</title>
      <authors>
	<author person="bec" />
	<author person="diwan" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/pldifit09-gradprog.pdf</url>
      </urls>
      <howpub>
	<proceedings event="pldi-fit09" />
      </howpub>
    </pub>

    <pub id="bto-sc09">
      <title>Automating the Generation of Composed Linear Algebra Kernels</title>
      <authors>
	<author person="belter" />
	<author person="jessup" />
	<author person="karlin" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/sc09.pdf</url>
      </urls>
      <howpub>
	<proceedings event="sc09" />
      </howpub>
      <abstract>
	<p>Memory bandwidth limits the performance of important
	kernels in many scientific applications. Such applications
	often use sequences of Basic Linear Algebra Subprograms
	(BLAS), and highly efficient implementations of those routines
	enable scientists to achieve high performance at little
	cost. However, tuning the BLAS in isolation misses
	opportunities for memory optimization that result from
	composing multiple subprograms. Because it is not practical to
	create a library of all BLAS combinations, we have developed a
	domain-specific compiler that generates them on demand. In
	this paper, we describe a novel algorithm for compiling linear
	algebra kernels and searching for the best combination of
	optimization choices. We also present a new hybrid
	analytic/empirical method for quickly evaluating the
	profitability of each optimization. We report experimental
	results showing speedups of up to 130% relative to the
	GotoBLAS on an AMD Opteron and up to 137% relative to MKL on
	an Intel Core 2.</p>
      </abstract>
    </pub>
  </publications>

  <persons>
    <person id="bec" group="faculty">
      <name>Bor-Yuh Evan Chang</name>
      <url>http://www.cs.colorado.edu/~bec/</url>
      <face>pics/chang.jpg</face>
    </person>
    <person id="diwan" group="faculty">
      <name>Amer Diwan</name>
      <url>http://www.cs.colorado.edu/~diwan/</url>
      <face>pics/diwan.jpg</face>
    </person>
    <person id="grunwald" group="faculty">
      <name>Dirk Grunwald</name>
      <url>http://systems.cs.colorado.edu/people/faculty/dirk-grunwald/</url>
      <face>pics/grunwald.jpg</face>
    </person>
    <person id="srirams" group="faculty">
      <name>Sriram Sankaranarayanan</name>
      <url>http://www.cs.colorado.edu/~srirams/</url>
      <face>pics/sankaranarayanan.jpg</face>
    </person>
    <person id="siek" group="faculty">
      <name>Jeremy G. Siek</name>
      <url>http://ecee.colorado.edu/~siek/</url>
      <face>pics/siek.jpg</face>
    </person>
    <person id="fabio" group="faculty">
      <name>Fabio Somenzi</name>
      <url>http://vlsi.colorado.edu/~fabio/</url>
      <face>pics/somenzi.jpg</face>
    </person>
    <person id="vachharajani">
      <name>Manish Vachharajani</name>
      <url>http://ecee.colorado.edu/~manishv/</url>
      <face>pics/generic-male.png</face>
    </person>
    <person id="arbrad">
      <name>Aaron R. Bradley</name>
      <url>http://ece.colorado.edu/~bradleya/</url>
    </person>
    <person id="msridhar">
      <name>Manu Sridharan</name>
      <url>https://researcher.ibm.com/researcher/view.php?person=us-msridhar</url>
    </person>
    <person id="belter" group="phd">
      <name>Geoffrey Belter</name>
      <face>pics/generic-male.png</face>
    </person>
    <person id="berdine">
      <name>Josh Berdine</name>
      <url>http://research.microsoft.com/en-us/people/jjb</url>
    </person>
    <person id="blackshear" group="phd">
      <name>Sam Blackshear</name>
      <url>http://cs.colorado.edu/~sabl4745</url>
      <face>pics/blackshear.jpg</face>
    </person>
    <person id="blomstedt" group="phd">
      <name>Joseph Blomstedt</name>
      <face>pics/generic-male.png</face>
    </person>
    <person id="chakarov" group="phd">
     <name>Aleksandar Chakarov</name>
     <face>pics/chakarov.jpg</face>
    </person>
    <person id="coughlin" group="phd">
      <name>Devin Coughlin</name>
      <face>pics/coughlin.jpg</face>
    </person>
    <person id="cox" group="phd">
      <name>Arlen Cox</name>
      <url>http://eces.colorado.edu/~coxaj/</url>
      <face>pics/cox.jpg</face>
    </person>
    <person id="gottschlich">
      <name>Justin E. Gottschlich</name>
      <face>pics/generic-male.png</face>
    </person>
    <person id="ishtiaq">
      <name>Samin Ishtiaq</name>
      <url>http://research.microsoft.com/en-us/people/sishtiaq</url>
    </person>
    <person id="jessup">
      <name>E.R. Jessup</name>
      <url>http://www.cs.colorado.edu/~jessup/</url>
    </person>
    <person id="karlin">
      <name>Ian Karlin</name>
      <face>pics/generic-male.png</face>
    </person>
    <person id="miao" group="phd">
      <name>Weiyu Miao</name>
      <face>pics/miao.jpg</face>
    </person>
    <person id="nelson" group="phd">
      <name>Thomas Nelson</name>
      <face>pics/nelson.jpg</face>
    </person>
    <person id="tsai" group="phd">
      <name>Yi-Fan Tsai</name>
      <face>pics/tsai.jpg</face>
    </person>
    <person id="turner" group="phd">
      <name>Jonathan Turner</name>
      <face>pics/turner.jpg</face>
    </person>
    <person id="vitousek" group="phd">
      <name>Michael Vitousek</name>
      <face>pics/vitousek.jpg</face>
    </person>
    <person id="adityaz" group="phd">
      <name>Aditya Zutshi</name>
      <face> pics/zutshi.jpg </face>
    </person>
    <person id="agrawal" group="ms">
      <name>Neelam Agrawal</name>
      <face>pics/generic-female.png</face>
    </person>
    <person id="bennett" group="ms">
      <name>Huck Bennett</name>
      <url>http://csel.cs.colorado.edu/~bennethd</url>  
      <face>pics/bennett.jpg</face>
    </person>
    <person id="bharadwaj" group="ms">
      <name>Shashank Bharadwaj</name>
      <face>pics/bharadwaj.jpg</face>
    </person>
    <person id="silkensen" group="ms">
      <name>Erik Silkensen</name>
      <url>http://csel.cs.colorado.edu/~silkense</url>
      <face>pics/silkensen.jpg</face>
    </person>
    <person id="frohardt">
      <name>Robert Frohardt</name>
      <url>http://www.cs.colorado.edu/~frohardt/</url>
    </person>
    <person id="creichen">
      <name>Christoph Reichenbach</name>
      <url>http://www.cs.umass.edu/~creichen/</url>
    </person>
    <person id="khooyp">
      <name>Khoo Yit Phang</name>
      <url>http://www.cs.umd.edu/~khooyp/</url>
    </person>
    <person id="jfoster">
      <name>Jeffrey S. Foster</name>
      <url>http://www.cs.umd.edu/~jfoster/</url>
    </person>
    <person id="laviron">
      <name>Vincent Laviron</name>
    </person>
    <person id="rival">
      <name>Xavier Rival</name>
      <url>http://www.di.ens.fr/~rival/</url>
    </person>
    <person id="atiwari">
      <name>Ashish Tiwari</name>
      <url>http://csl.sri.com/~tiwari/</url>
    </person>
    <person id="colonm">
      <name>Michael Colon</name>
    </person>
    <person id="fp">
      <name>Frank Pfenning</name>
      <url>http://www.cs.cmu.edu/~fp/</url>
    </person>
    <person id="astump">
      <name>Aaron Stump</name>
      <url>http://www.cs.uiowa.edu/~astump/</url>
    </person>
    <person id="cesar">
      <name>César Sánchez</name>
      <url>http://software.imdea.org/~cesar/</url>
    </person>
    <person id="asanchez">
      <name>Alejandro Sánchez</name>
      <url>http://software.imdea.org/people/alejandro.sanchez/index.html</url>
    </person>
    <person id="swarat">
      <name>Swarat Chaudhuri</name>
      <url>http://www.cse.psu.edu/~swarat/</url>
    </person>
    <person id="putot">
      <name>Sylvie Putot</name>
      <url>http://www.lix.polytechnique.fr/Labo/Sylvie.Putot/</url>
    </person>
    <person id="goubault">
      <name>Eric Goubault</name>
      <url>http://www.lix.polytechnique.fr/~goubault/</url>
    </person>
    <person id="bycook">
      <name>Byron Cook</name>
      <url>http://research.microsoft.com/en-us/people/bycook/</url>
    </person>
    <person id="wintersteiger">
      <name>Christoph Wintersteiger</name>
      <url>http://research.microsoft.com/en-us/people/cwinter</url>
    </person>
    <person id="chaowang">
      <name>Chao Wang</name>
      <url>http://www.nec-labs.com/~chaowang/</url>
    </person>
    <person id="ivancic">
      <name>Franjo Ivančić</name>
      <url>http://www.nec-labs.com/~ivancic/</url>
    </person>
    <person id="burtscher">
      <name>Martin Burtscher</name>
      <url>http://www.cs.txstate.edu/~mb92/</url>
    </person>
    <person id="bradchen">
      <name>Brad Chen</name>
      <url>http://research.google.com/pubs/author37895.html</url>
    </person>
    <person id="bodik">
      <name>Rastislav Bodik</name>
      <url>http://www.cs.berkeley.edu/~bodik/</url>
    </person>
    <person id="bcpierce">
      <name>Benjamin C. Pierce</name>
      <url>http://www.cis.upenn.edu/~bcpierce/</url>
    </person>
    <person id="birkedal">
      <name>Lars Birkedal</name>
      <url>http://www.itu.dk/~birkedal/</url>
    </person>
    <person id="mstrout">
      <name>Michelle Mills Strout</name>
      <url>http://www.cs.colostate.edu/~mstrout/</url>
    </person>
    <person id="ssuryana">
      <name>Siddharth Suryanarayanan</name>
      <url>http://www.engr.colostate.edu/~ssuryana/</url>
    </person>
    <person id="fainekosg">
      <name>Georgios Fainekos</name>
      <url>http://www.public.asu.edu/~gfaineko/</url>
    </person>
    <person id="yeshwanta">
      <name>Yashwant Annapureddy</name>
    </person>
    <person id="liuche">
      <name>Che Liu</name>
    </person>
    <person id="amal">
      <name>Amal Ahmed</name>
      <url>https://www.cs.indiana.edu/~amal/</url>
    </person>
    <person id="robby">
      <name>Robert Bruce Findler</name>
      <url>http://www.eecs.northwestern.edu/~robby/</url>
    </person>
    <person id="wadler">
      <name>Philip Wadler</name>
      <url>http://homepages.inf.ed.ac.uk/wadler/</url>
    </person>
    <person id="toddm">
      <name>Todd Mytkowicz</name>
      <url>http://research.microsoft.com/en-us/people/toddm/</url>
    </person>
    <person id="sweeney">
      <name>Peter F. Sweeney</name>
      <url>https://researcher.ibm.com/researcher/view.php?person=us-pfs</url>
    </person>
    <person id="hauswirth">
      <name>Matthias Hauswirth</name>
      <url>http://www.inf.usi.ch/faculty/hauswirth/</url>
    </person>
    <person id="hassanz">
      <name>Zyad Hassan</name>
      <url>http://eces.colorado.edu/~hassanz/</url>
    </person>
    <person id="yanzhang">
      <name>Yan Zhang</name>
    </person>
    <person id="schramme">
      <name>Peter Schrammel</name>
      <url>http://pop-art.inrialpes.fr/people/schramme/</url>
    </person>
    <person id="bjeannet">
      <name>Bertrand Jeannet</name>
      <url>http://pop-art.inrialpes.fr/~bjeannet/</url>
    </person>
    <person id="thiagu">
      <name>P.S. Thiagarajan</name>
      <url>http://www.comp.nus.edu.sg/~thiagu/</url>
    </person>
  </persons>

  <events>
    <series id="popl">
      <name>Principles of Programming Languages</name>
      <longPrefix>ACM SIGACT-SIGPLAN Symposium on</longPrefix>
      <event id="popl12">
	<date>2012-01</date>
	<location>Philadelphia, Pennsylvania, USA</location>
	<nth>Thirty-Ninth</nth>
	<url>http://www.cse.psu.edu/popl/12/</url>
      </event>
      <event id="popl11">
	<date>2011-01</date>
	<location>Austin, Texas, USA</location>
	<nth>Thirty-Eighth</nth>
	<url>http://www.cse.psu.edu/popl/11/</url>
      </event>
      <event id="popl10">
	<date>2010-01</date>
	<location>Madrid, Spain</location>
	<nth>Thirty-Seventh</nth>
	<url>http://www.cse.psu.edu/popl/10/</url>
      </event>
      <event id="popl08">
	<date>2008</date>
	<location>San Francisco, California, USA</location>
	<nth>Thirty-Fifth</nth>
	<url>http://www.cs.ucsd.edu/popl/08/</url>
      </event>
    </series>
    <series id="pldi">
      <name>Programming Language Design and Implementation</name>
      <longPrefix>ACM SIGPLAN Conference on</longPrefix>
      <event id="pldi10">
	<date>2010-06</date>
	<location>Toronto, Ontario, Canada</location>
	<url>http://www.cs.stanford.edu/pldi10/</url>
      </event>
      <event id="pldi09">
	<date>2009</date>
	<location>Dublin, Ireland</location>
	<url>http://www.cs.colorado.edu/pldi09/</url>
      </event>
    </series>
    <series id="cav">
      <name>Computer Aided Verification</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="cav11">
	<date>2011-07</date>
	<location>Snowbird, Utah, USA</location>
	<url>http://www.cs.utah.edu/events/conferences/cav2011/</url>
      </event>
      <event id="cav12">
	<date>2012-07</date>
	<location>Berkeley, California, USA</location>
	<url>http://cav12.cs.illinois.edu/</url>
      </event>
    </series>
    <series id="esop">
      <name>European Symposium on Programming</name>
      <event id="esop11">
	<date>2011-03</date>
	<location> Saarbrücken, Germany </location>
        <url>http://www.etaps.org/etaps-2011/esop</url>
      </event>
      <event id="esop10"> 
	<date>2010-03</date>
	<location>Paphos, Cyprus</location>
	<nth>Nineteenth</nth>
	<url>http://research.microsoft.com/en-us/um/people/adg/esop2010/</url>
      </event>
    </series>
    <series id="tacas">
      <name>Tools and Algorithms for the Construction and Analysis of Systems</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="tacas12">
	<date>2012-03</date>
	<location>Tallinn, Estonia</location>
	<nth>Eighteenth</nth>
	<url>http://www.etaps.org/2012/tacas/</url>
      </event>
      <event id="tacas11">
	<date>2011-03</date>
	<location>Saarbrücken, Germany</location>
	<url>http://www.etaps.org/etaps-2011/tacas</url>
      </event>
    </series>
    <series id="sas">
      <name>Static Analysis Symposium</name>
      <longPrefix>International</longPrefix>
      <event id="sas11">
	<date>2011-09</date>
	<location>Venice, Italy</location>
	<nth>Eighteenth</nth>
	<url>http://sas2011.cs.technion.ac.il/</url>
      </event>
      <event id="sas12">
	<date>2012-09</date>
	<location>Deauville, France</location>
	<nth>Nineteenth</nth>
	<url>http://www.sas2012.ens.fr/</url>
      </event>
      <event id="sas07">
	<date>2007</date>
	<nth>Fourteenth</nth>
	<url>http://www2.imm.dtu.dk/sas2007/</url>
      </event>
    </series>
    <series id="vmcai">
      <name>Verification, Model Checking, and Abstract Interpretation</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="vmcai11">
	<date>2011-01</date>
	<location>Austin, Texas, USA</location>
	<nth>Twelfth</nth>
	<url>http://vmcai11.cis.ksu.edu/</url>
      </event>
    </series>
    <series id="issta">
      <name>Software Testing and Analysis</name>
      <longPrefix>International Symposium on</longPrefix>
      <event id="issta12">
	<date>2012-07</date>
	<location>Minneapolis, Minnesota, USA</location>
	<nth>Twenty-First</nth>
	<url>http://crisys.cs.umn.edu/issta2012/</url>
      </event>
    </series>
    <series id="hscc">
      <name>Hybrid Systems: Computation and Control</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="hscc11">
	<date>2011-04</date>
	<location>Chicago, Illinois, USA</location>
	<url>http://hscc2011.cs.sunysb.edu/</url>
      </event>
    </series>
    <series id="fmcad">
      <name>Formal Methods in Computer Aided Design</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="fmcad11">
	<date>2011-10</date>
	<location>Austin, Texas, USA</location>
	<url>http://www.cs.utexas.edu/~ragerdl/fmcad11/</url>
      </event>
    </series>
    <series id="nsad">
      <name>Numerical and Symbolic Abstract Domains</name>
      <longPrefix>International Workshop on</longPrefix>
      <event id="nsad11">
	<date>2011</date>
	<nth>Third</nth>
	<url>http://software.imdea.org/events/nsad2011/</url>
      </event>
    </series>
    <series id="paste">
      <name>Program Analysis for Software Tools and Engineering</name>
      <longPrefix>ACM SIGPLAN-SIGSOFT Workshop on</longPrefix>
      <event id="paste11">
	<date>2011</date>
	<nth>Tenth</nth>
	<url>https://sites.google.com/site/paste2011/</url>
      </event>
    </series>
    <series id="pldi-fit">
      <name>Fun Ideas and Thoughts at PLDI</name>
      <event id="pldi-fit09">
	<date>2009</date>
	<url>http://www.cs.colorado.edu/pldi09/fit/</url>
	<location>Dublin, Ireland</location>
      </event>
    </series>
    <series id="fractal">
      <name>Front Range Architecture Compilers Tools and Languages Workshop</name>
      <event id="fractal-f09">
	<date>F2009</date>
	<url>http://fractal.cs.colorado.edu/</url>
	<location>Boulder, Colorado, USA</location>
      </event>
    </series>
    <series id="mvd">
      <name>Midwest Verification Day</name>
      <event id="mvd12">
	<date>2012-09</date>
	<url>http://www.ittc.ku.edu/mvd12/</url>
	<location>Lawrence, Kansas, USA</location>
      </event>
    </series>
    <series id="gpce">
      <name>Generative Programming and Component Engineering</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="gpce10">
         <date>2010-10</date>
         <location>Eindhoven, The Netherlands</location>
         <nth>Ninth</nth>
         <url>http://www.program-transformation.org/GPCE10/</url>
      </event>
    </series>
    <series id="sc">
     <name>International Conference on High Performance Computing Networking, Storage and Analysis</name>
     <event id="sc09">
       <location>Portland, Oregon, USA</location>
       <date>2009-11</date>
     </event>
    </series>
    <series id="cgo">
     <name>Code Generation and Optimization</name>
     <longPrefix>International Symposium on</longPrefix>
     <event id="cgo10">
       <location>Toronto, Ontario, Canada</location>
       <date>2010-04</date>
       <url>http://www.cgo.org/cgo2010/</url>
     </event>
    </series>
  </events>
</cv>
